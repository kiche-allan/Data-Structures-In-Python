(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Pipeline
     *
     * Pipeline class containing stages which will be executed in sequence. Stages need to implement the IStage interface
     * and are responsible for calling the "next" method of the pipeline to advance to the next stage. When a stage is
     * either resolved or rejected control is given back to the class that called next on the pipeline, triggering the
     * stage execution. When the first stage in the pipeline is resolved (it resolves last since it will wait for all other
     * stages in the pipeline to resolve first) the pipeline is resolved with the output from the first stage. Stages can
     * therefore modify output before and after the "next" call.
     *
     * @module j-stillery/Pipeline
     * @author Sandhj√© Bouw (sandhje@ecodes.io)
     */
    var Pipeline = (function () {
        function Pipeline() {
            var _this = this;
            /**
             * The position of the current stage being executed
             *
             * This counter will be incremented each time a "next" stage is being called. It will not decrement on stages being
             * resolved. Therefore, when the pipeline as fully run and resolves the "current" counter will equal the amount of
             * stages piped.
             *
             * @var number
             */
            this.current = -1;
            /**
             * The stages registry containing all stages piped onto the pipeline
             *
             * @var Array<IStage<T>>
             */
            this.stages = [];
            /**
             * Call the next stage in the pipeline
             *
             * On invoking a stage pass this callback so the invoked stage has control over when to call the next
             * stage in the pipeline. The callback returns a promise with the output value of the next stage.
             *
             * @callback (input: T): Promise<T>
             */
            this.next = function (input) {
                return new Promise(function (resolve, reject) {
                    _this.incrementCurrent();
                    var currentStage = _this.getCurrentStage();
                    if (currentStage !== null) {
                        // Go to next in filter chain
                        currentStage.invoke(input, _this.next, resolve, reject);
                        return;
                    }
                    // End of Pipeline
                    _this.end(input, resolve, reject);
                });
            };
        }
        /**
         * Get the position of the current stage being executed
         *
         * @returns number
         */
        Pipeline.prototype.getCurrent = function () {
            return this.current;
        };
        /**
         * Get the current stage being executed
         *
         * @returns IStage<T>
         */
        Pipeline.prototype.getCurrentStage = function () {
            if (this.current in this.stages) {
                return this.stages[this.current];
            }
            return null;
        };
        /**
         * Get all stages piped onto the pipeline
         *
         * @returns Array<IStage<T>>
         */
        Pipeline.prototype.getStages = function () {
            return this.stages;
        };
        /**
         * @see IPipeline::pipe
         */
        Pipeline.prototype.pipe = function (stage) {
            this.pushStage(stage);
            return this;
        };
        /**
         * @see IPipeline::run
         */
        Pipeline.prototype.run = function (input) {
            this.reset();
            return this.next(input);
        };
        /**
         * Increment the pipeline's internal active stage position
         *
         * @returns void
         */
        Pipeline.prototype.incrementCurrent = function () {
            this.current++;
        };
        /**
         * Add the passed stage to the internal stages "registry"
         *
         * @param IStage<T> stage
         * @returns void
         */
        Pipeline.prototype.pushStage = function (stage) {
            this.stages.push(stage);
        };
        /**
         * Reset the pipeline's internal active stage position to it's start value
         *
         * @returns void
         */
        Pipeline.prototype.reset = function () {
            this.current = -1;
        };
        /**
         * End the pipeline
         *
         * This method acts as a "null-stage" immediatly resolving with the input value. This triggers the then callbacks on
         * the "next" calls in all executed stages.
         *
         * @param T input
         * @param function resolve
         * @param function reject
         */
        Pipeline.prototype.end = function (input, resolve, reject) {
            resolve(input);
        };
        return Pipeline;
    }());
    exports.Pipeline = Pipeline;
});
//# sourceMappingURL=Pipeline.js.map