(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _1 = require("../");
    /**
     * Filter stage: run "sub-stages" conditionally
     *
     * The filter stage is a "wrapper" stage implementing the IPipeable interface. Other stages can be piped onto the
     * filter stage. These stages will then be run conditionally based on the result of a "matcher". All these stages
     * will be invoked as part of the normal flow of the pipeline.
     *
     * @package j-stillery/Filter
     * @author Sandhj√© Bouw (sandhje@ecodes.io)
     */
    var Filter = (function () {
        /**
         * Filter stage constructor
         *
         * The passed match strategies or callbacks will be executed before invoking the "sub-stages" piped onto this
         * stage. If the matcher returns boolean true the "sub-pipeline" with the "sub-stages" will be run for both "up"
         * and "down" processes. If no matcher it will default to false, not executing the "sub-pipeline".
         *
         * @param IMatchStrategy<T>|IMatchCallback<T> match
         */
        function Filter(match) {
            if (match === void 0) { match = null; }
            this.match = match;
            /**
             * Filter pipeline
             *
             * The "sub-pipeline" which will be executed conditionally as part of the main pipeline if the matcher for this
             * filter matches.
             *
             * @var FilterPipeline<T>
             */
            this._filterPipeline = null;
        }
        Object.defineProperty(Filter.prototype, "filterPipeline", {
            /**
             * Filter pipeline getter
             *
             * @returns FilterPipeline<T>
             */
            get: function () {
                if (this._filterPipeline === null) {
                    this._filterPipeline = new _1.SubPipeline();
                }
                return this._filterPipeline;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Pipe stages to be executed conditionally onto the filter stage
         *
         * @param IStage<T> stage
         * @returns Filter<T>
         */
        Filter.prototype.pipe = function (stage) {
            this.filterPipeline.pipe(stage);
            return this;
        };
        /**
         * Invoke the filter stage
         *
         * Calling this method will trigger evaluations of the matcher with the passed input. If the matcher returns boolean
         * true the "sub-stages" will be invoked for both "up" and "down" processes.
         *
         * @param T input
         * @param function next
         * @param function resolve
         * @param function reject
         */
        Filter.prototype.invoke = function (input, next, resolve, reject) {
            if (this.matches(input)) {
                // Set the parent next of the "filter" pipeline
                this.filterPipeline.setParentNext(next);
                // Run "filter" pipeline and resolve once done
                this.filterPipeline.run(input).then(function (value) {
                    resolve(value);
                }).catch(function (reason) {
                    reject(reason);
                });
            }
            else {
                // Skip the filter pipeline
                next(input).then(function (value) {
                    resolve(value);
                }).catch(function (reason) {
                    reject(reason);
                });
            }
        };
        /**
         * Execute the injected matcher with the passed input
         *
         * @param T input
         * @returns bool
         */
        Filter.prototype.matches = function (input) {
            if (this.isMatchCallback(this.match)) {
                return this.match(input);
            }
            if (this.isMatchStrategy(this.match)) {
                return this.match.match(input);
            }
            return false;
        };
        /**
         * Match strategy type guard
         *
         * Check wether the matcher adheres to the interface of an IMatchStrategy.
         *
         * @param any matcher
         * @returns bool
         */
        Filter.prototype.isMatchStrategy = function (matcher) {
            return (matcher !== null
                && typeof matcher === "object"
                && typeof matcher.match === "function");
        };
        /**
         * Match callback type guard
         *
         * Check wether the matcher adheres to the interface of an IMatchCallback.
         *
         * @param any matcher
         * @returns bool
         */
        Filter.prototype.isMatchCallback = function (match) {
            return typeof match === "function";
        };
        return Filter;
    }());
    exports.Filter = Filter;
});
//# sourceMappingURL=Filter.js.map