(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Parallel stage wrapper
     *
     * This class serves as a wrapper for the stages piped onto the parallel stage. This allows the parallel stage to
     * execute the wrapped stages "up" and handing control back to the pipeline once all stages called next. When the
     * "next" stages in the pipeline return this wrapper will allow the parallel stage to execute the wrapped stages "down".
     *
     * @package j-stillery/ParallelStage
     * @author Sandhj√© Bouw (sandhje@ecodes.io)
     */
    var ParallelStage = (function () {
        /**
         * Constructor for the parallel stage wrapper
         *
         * Pass the stage to be wrapped as the first argument.
         *
         * @param IStage<T> stage
         */
        function ParallelStage(stage) {
            var _this = this;
            this.stage = stage;
            /**
             * The next callback for the wrapped stage
             * StageNext is being called from the wrapped stage on completion of it's "up" process. execute resolveUp here and
             * wait with resoving the returned promise untill executeDown is called, triggering the "down" process of the
             * wrapped stage.
             *
             * @callback (value: T) => Promise<T>
             */
            this.stageNext = function (value) {
                return new Promise(function (resolveNext, rejectNext) {
                    _this.resolveNext = resolveNext;
                    _this.rejectNext = rejectNext;
                    _this.resolveUp(value);
                });
            };
        }
        /**
         * Execute the "up" process of the wrapped stage
         *
         * Returns a promise with the result of the "up" process. Internally defers the execution of the wrapped stage to
         * the "invokeStage" method on this class.
         *
         * @param T input
         * @returns Promise<T>
         */
        ParallelStage.prototype.executeUp = function (input) {
            var _this = this;
            // Invoke stage and hold next so "down" of stage does not get called
            return new Promise(function (resolve, reject) {
                _this.resolveUp = resolve;
                _this.rejectUp = reject;
                _this.invokePromise = _this.invokeStage(input);
            });
        };
        /**
         * Execute the "down" process of the wrapped stage
         *
         * Returns a promise with the result of the "down" process. Resolves the promise from "stageNext", which is passed
         * as the "next" argument to the wrapped stage, triggering the "down" process of the wrapped stage. When the "down"
         * process of the wrapped stage is finished (the stage resolved) the promise returned from this method will resolve.
         *
         * @param T output
         * @param Promise<T>
         */
        ParallelStage.prototype.executeDown = function (output) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.invokePromise.then(function (value) {
                    resolve(value);
                });
                // resolve next so "down" of stage gets called
                _this.resolveNext(output);
            });
        };
        /**
         * Invoke the wrapped stage
         *
         * Pass the "stageNext" method of this class to the stage as its "next" parameter so we can resolve the "next" of
         * wrapped stage "on demand" by calling "executeDown". This will trigger the "down" process in the wrapped stage.
         *
         * @param T input
         * @returns Promise<T>
         */
        ParallelStage.prototype.invokeStage = function (input) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.stage.invoke(input, _this.stageNext, resolve, reject);
            });
        };
        return ParallelStage;
    }());
    exports.ParallelStage = ParallelStage;
});
//# sourceMappingURL=ParallelStage.js.map