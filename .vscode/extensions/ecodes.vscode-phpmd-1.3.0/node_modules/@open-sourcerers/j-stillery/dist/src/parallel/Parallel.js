(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./ParallelStage"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ParallelStage_1 = require("./ParallelStage");
    /**
     * Parallel stage: run "sub-stages" in parallel
     *
     * The parallel stage is a "wrapper" stage implementing the IPipeable interface. Other stages can be piped onto the
     * parallel stage. These stages will then be run in parallel instead of in sequence. All these stages will be invoked
     * with the same initial input. After being run the outcome of the stages piped onto the parallel stage need te be
     * merged.
     *
     * @package j-stillery/Parallel
     * @author Sandhj√© Bouw (sandhje@ecodes.io)
     */
    var Parallel = (function () {
        /**
         * Parallel constructor
         *
         * The passed merge strategies or callbacks will be executed after the up process (mergeUp) and down process
         * (mergeDown) for all the stages piped onto the parallel stage were executed, giving the consumer the ability
         * to merge the outputs from all stages for both processes. If the "up" or "down" parameters are not supplied the
         * parallel stage will resolve its up or down processes immediatly with its input, ignoring the results from the
         * piped stages.
         *
         * @param IMergeStrategy<T>|IMergeCallback<T> up
         * @param IMergeStrategy<T>|IMergeCallback<T> down
         */
        function Parallel(mergeUp, mergeDown) {
            if (mergeUp === void 0) { mergeUp = null; }
            if (mergeDown === void 0) { mergeDown = null; }
            this.mergeUp = mergeUp;
            this.mergeDown = mergeDown;
            /**
             * Container for all stages piped onto the parallel stage
             *
             * Stages in this container are already wrapped by the parallel stage class.
             *
             * @var Array<ParallelStage<T>>
             */
            this.stages = [];
        }
        /**
         * Pipe stages to be executed in parallel onto the parallel stage
         *
         * This method wraps all passed stages with the parallelStage class to enable full control over execution of its
         * "up" and "down" processes.
         *
         * @param Stage<T> stage
         * @returns Parallel<T>
         */
        Parallel.prototype.pipe = function (stage) {
            this.stages.push(new ParallelStage_1.ParallelStage(stage));
            return this;
        };
        /**
         * Invoke the parallel stage
         *
         * Calling this method invokes all stages piped onto this stage in parallel. Once all of these "sub-stages" have
         * completed their "up" process the merge strategy or callback will be executed with the result of all "sub-stages".
         * After merging, the "up" process for this parallel stage is complete and the next stage in the pipeline is called.
         * When the next stage in the pipeline is resolved, the "down" process of the "sub-stages" will be started and the
         * results will once again be merged by the merge strategy or callback. Once done merging the result from all "down"
         * processes the parallel stage itself is done with its "down" process and resolves with the merged output, handing
         * control back over to the pipeline, which will call the preceding stage or resolve.
         *
         * @param T input
         * @param function next
         * @param function resolve
         * @param function reject
         * @returns void
         */
        Parallel.prototype.invoke = function (input, next, resolve, reject) {
            var _this = this;
            var promisesUp = [];
            this.stages.every(function (stage) {
                promisesUp.push(stage.executeUp(input));
                return true;
            });
            Promise.all(promisesUp).then(function (values) {
                var merged = _this.merge(_this.mergeUp, input, values);
                return next(merged);
            }).then(function (value) {
                var promisesDown = [];
                _this.stages.every(function (stage) {
                    promisesDown.push(stage.executeDown(value));
                    return true;
                });
                Promise.all(promisesDown).then(function (values) {
                    var merged = _this.merge(_this.mergeDown, value, values);
                    resolve(merged);
                });
            });
        };
        /**
         * Merge an array of, in parallel executed stage results, into one result
         *
         * @param IMergeStrategy<T>|IMergeCallback<T> mergable
         * @param T input
         * @param Array<T> results
         * @returns T
         */
        Parallel.prototype.merge = function (mergable, input, results) {
            if (this.isMergeCallback(mergable)) {
                return mergable(input, results);
            }
            if (this.isMergeStrategy(mergable)) {
                return mergable.merge(input, results);
            }
            return input;
        };
        ;
        /**
         * Mergable strategy type guard
         *
         * Check wether the mergable adheres to the interface of an IMergableStrategy.
         *
         * @param any mergeable
         * @returns bool
         */
        Parallel.prototype.isMergeStrategy = function (mergeable) {
            return (mergeable !== null
                && typeof mergeable === "object"
                && typeof mergeable.merge === "function");
        };
        /**
         * Mergable callback type guard
         *
         * Check wether the mergable adheres to the interface of an IMergableCallback.
         *
         * @param any mergeable
         * @returns bool
         */
        Parallel.prototype.isMergeCallback = function (mergeable) {
            return typeof mergeable === "function";
        };
        return Parallel;
    }());
    exports.Parallel = Parallel;
});
//# sourceMappingURL=Parallel.js.map