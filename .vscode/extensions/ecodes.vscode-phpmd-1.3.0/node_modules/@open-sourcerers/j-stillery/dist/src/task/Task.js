(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Generic "task" stage
     *
     * The task stage is a stage that can be configured with execute strategies or callbacks. These strategies will be
     * called on the appropriate times in the IStage::invoke method, eliminating the need for the consumer to write their
     * own implementation of this interface while retaining all flexibility.
     *
     * The up and down strategies (or callbacks) are called before (up) and after (down) the next stage in the pipeline is
     * invoked.
     *
     * @package j-stillery/Task
     * @author Sandhj√© Bouw (sandhje@ecodes.io)
     */
    var Task = (function () {
        /**
         * Task constructor
         *
         * The passed execute strategies or callbacks will be executed before (up) and after (down) the next stage in the
         * pipeline is invoked, giving the consumer two moments to modify the input. If the "up" or "down" parameters are
         * not supplied the task will resolve the up or down action immediatly with it's input.
         *
         * @param IExecuteStrategy<T>|IExecuteCallback<T> up
         * @param IExecuteStrategy<T>|IExecuteCallback<T> down
         */
        function Task(up, down) {
            if (up === void 0) { up = null; }
            if (down === void 0) { down = null; }
            this.up = up;
            this.down = down;
        }
        /**
         * @see IStage::invoke
         */
        Task.prototype.invoke = function (input, next, resolve, reject) {
            var _this = this;
            var promiseIn = new Promise(function (resolveIn, rejectIn) {
                _this.execute(_this.up, input, resolveIn, rejectIn);
            });
            promiseIn.then(function (value) {
                return next(value);
            }).then(function (value) {
                return new Promise(function (resolveOut, rejectOut) {
                    _this.execute(_this.down, value, resolveOut, rejectOut);
                });
            }).then(function (value) {
                resolve(value);
            }).catch(function (reason) {
                reject(reason);
            });
        };
        /**
         * Run the passed executable
         *
         * If the passed executable is neither a IExecuteStrategy not a IExecuteCallback this method will call the resolve
         * argument with unmodified input.
         *
         * @param IExecuteStrategy<T>|IExecuteCallback<T> executable
         * @param T input
         * @param function resolve
         * @param function reject
         * @returns void
         */
        Task.prototype.execute = function (executable, input, resolve, reject) {
            if (this.isExecuteStrategy(executable)) {
                return executable.execute(input, resolve, reject);
            }
            if (this.isExecuteCallback(executable)) {
                return executable(input, resolve, reject);
            }
            resolve(input); // Resolve with input if no execute strategy or callback passed
        };
        /**
         * Executable strategy type guard
         *
         * Check wether the executable adheres to the interface of an IExecutableStrategy.
         *
         * @param any executable
         * @returns bool
         */
        Task.prototype.isExecuteStrategy = function (executable) {
            return (executable !== null
                && typeof executable === "object"
                && typeof executable.execute === "function");
        };
        /**
         * Executable callback type guard
         *
         * Check wether the executable adheres to the interface of an IExecutableCallback.
         *
         * @param any executable
         * @returns bool
         */
        Task.prototype.isExecuteCallback = function (executable) {
            return typeof executable === "function";
        };
        return Task;
    }());
    exports.Task = Task;
});
//# sourceMappingURL=Task.js.map