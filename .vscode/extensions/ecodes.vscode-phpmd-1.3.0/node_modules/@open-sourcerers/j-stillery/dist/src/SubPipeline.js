var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Pipeline"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Pipeline_1 = require("./Pipeline");
    /**
     * Sub pipeline
     *
     * The "sub-pipeline"" is a pipeline which can run as part of a stage (e.g. the filter stage) in the "main" pipeline.
     * Stages can be piped onto the sub pipeline and when the pipeline run's it will hand control back to the "main"
     * pipeline once it completes its "up" process. When the next stage in the "main" pipeline resolves, this
     * "sub-pipeline" will resume with its "down" process.
     *
     * If the next stage of the main (parent) pipeline is not set before the pipeline has completed it's "up" process, the
     * pipeline will resolve the "up" process like any other and immediatly continue with its down process.
     *
     * @package j-stillery/SubPipeline
     * @author Sandhj√© Bouw (sandhje@ecodes.io)
     */
    var SubPipeline = (function (_super) {
        __extends(SubPipeline, _super);
        function SubPipeline() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Parent next setter
         *
         * @param function parentNext
         * @returns void
         */
        SubPipeline.prototype.setParentNext = function (parentNext) {
            this.parentNext = parentNext;
        };
        /**
         * End override
         *
         * Override for the pipeline's end method. Allows to hand control back to the "main" pipeline once this "sub"
         * pipeline completes its "up" process. Once the next stage in the "main" pipeline resolves the "down" process
         * in this "sub" pipeline is executed.
         *
         * @param T input
         * @param function resolve
         * @param function reject
         */
        SubPipeline.prototype.end = function (input, resolve, reject) {
            if (typeof this.parentNext !== "function") {
                resolve(input);
            }
            // On end of the "filter" pipeline, continue with parent
            // Once parent comes back, continue back down the "filter"
            this.parentNext(input).then(function (output) {
                resolve(output);
            }).catch(function (reason) {
                reject(reason);
            });
        };
        return SubPipeline;
    }(Pipeline_1.Pipeline));
    exports.SubPipeline = SubPipeline;
});
//# sourceMappingURL=SubPipeline.js.map